var tipuesearch = {"pages": [{'title': 'Introduction', 'text': '機械設計工程系 2019 Spring 協同產品設計實習 (Introduction to Collaborative Product Design Practice) \n 倉儲:\xa0 https://github.com/mdecourse/cd2019 \n 靜態網頁:  https://mde.tw/cd2019 \xa0 \n 動態網頁:  https://cd2019.herokuapp.com \xa0 \n 世界經濟論壇 2018 未來工作報告.pdf \n 2022 年之前, 企業預計納用技術比例列表 \n \n 各企業穩定, 新增與多餘工作角色列表 \n \n 電腦輔助設計室與協同設計室行事曆 \n 全頁檢視 \n \n 107學年教育目標: \n 本課程延續四技部計算機程式與電腦輔助設計實習之教學內容, 探討如何在網際協同環境進行機械產品開發. \n 107-2學期教育目標: \n 使用可攜程式系統, 以及\xa0 CMSimfly  與  portable Git  管理各學員與分組的動態與靜態網際內容管理系統, 同時利用  Onshape  與  V-rep  執行機電資整合產品開發, 當面臨各協同設計階段所遭遇問題時, 各學員可利用客製化程式加以解決. \n 達成學期教育目標之評量方式與標準: \n 評分比例: \n 學員出席 (20%) \n Github 倉儲管理\xa0 (20%) \n Onshape 協同操作 (20%) \n V-rep 模擬 (20%) \n 程式開發 (20%) \n 評分方式: \n CD 每週自評與互評表單:\xa0 https://goo.gl/forms/qtk5fxdeGYHCeI1M2 \xa0 \n 學員自我評量 \xa0(30%) \n 分組自我評量 (30%) \n 倉儲歷程查驗 (40%) \n 教學方式: \n 課堂講授 \n 操作錄影 \n 學員實習 \n 分組報告 \n 參考資料: \n https://open.umn.edu/opentextbooks/subjects/engineering \xa0', 'tags': '', 'url': 'Introduction.html'}, {'title': '實習任務', 'text': '2019 Spring 協同產品設計實習課程的目標 \n \n 讓學員得以利用  Onshape  以協同模式, 進行機電資有關的產品開發, 並利用  V-rep  執行該產品的模擬驗證. \n 各學員必須每週進行學習自評與互評, 並學習如何透過內容充實 (使用夠好麥克風錄音) 的影片 (on Youtube) 發表心得. \n', 'tags': '', 'url': '實習任務.html'}, {'title': '實習任務一', 'text': '學習要點 \n 本學期的課程將從各學員自行製作可攜程式系統開始, 讓各學員以團隊協同的方式整理資料, 並且推選代表進行簡報. \n 此外, 透過 ungit 的導入, 讓 git 與 github 在圖形化介面與中文提交訊息的交互應用下, 能夠更加提升學習效果. \n 最後, 本學期希望能改寫  Pygrouf  成為合用的網際同儕互評暨自評系統. \n 各學員執行任務 \n 請根據\xa0 http://mde.tw/wcm2019/content/實習項目二.html \xa0中的說明: \n \n 自行建立一套可攜程式系統, 並將過程製作成 3~5 分鐘的簡報, 各班每十號推選一名代表利用課堂時間進行簡報說明. \n 請設法利用 ungit 管理自己的協同產品設計實習課程網頁 (格式自選, 系統自選). \n \n 請以各班每十號為一組, 研讀 Git 教材:\xa0 https://git-scm.com/book/zh-tw/v2 \xa0並各自執行下列教材後, 推選一名代表利用課堂時間進行 3~5 分鐘的內容簡報說明. \n Github 教材:\xa0 https://lab.github.com/ \xa0 (已經以 scrum-1 帳號開始 學習流程 ) \n \n \n 學習成果驗收 \n \n 各學員確實閱讀\xa0 http://mde.tw/wcm2019/content/實習項目二.html \xa0中的說明, 並學會自行製作可攜程式系統. \n 各學員確實研讀 Git 教材:\xa0 https://git-scm.com/book/zh-tw/v2 \xa0內容, 能夠整理出 3~5 分鐘的簡報. \n 各學員確實執行\xa0 https://lab.github.com/ \xa0 中的導引內容, 並能夠整理出 3~5 分鐘的簡報. \n \n', 'tags': '', 'url': '實習任務一.html'}, {'title': '建立可攜程式系統', 'text': '操作影片 \n 安裝 Python 3.7.2 \n 修改 Scripts/pip.exe 中的系統連結設定 \n HxD:\xa0 https://mh-nexus.de/en/hxd/ \xa0 \n 納入相關工具 \n 利用 pip 安裝或移除 Python 模組 \n 不同 home 的啟動設置 \n https://github.com/mottosso/Qt.py \xa0(439 個 stars) 與\xa0 https://github.com/spyder-ide/qtpy \xa0(255 個 stars) 的選擇.\xa0 \n 對話:\xa0 https://github.com/spyder-ide/qtpy/issues/69 \xa0 \n', 'tags': '', 'url': '建立可攜程式系統.html'}, {'title': '第一週分組程式', 'text': '"程式"中的"程"表示流程, 而"式"則指採用特定格式, 因此"程式"可以解釋為利用特定格式的語法來表達特定流程. \n 至於電腦程式 (或計算機程式), 則特指該流程是利用電腦執行, 而所謂的特定格式則指採用特定的計算機語言, 與本網誌相關的課程, 主要採用 Python, 其次還使用 Javascript, C/C++ 與 Lua 等程式語言. \n 學習計算機程式, 特定語言的語法與解題流程互為因果, 因此在過程中, 除了必須了解各程式語言的基本範式及語法外, 還需要針對解題流程中所使用的資料結構與演算法進行取捨, 對於中型以上程式, 還需選擇採用何種資料庫系統. \n 希望利用 Python 對各班學員亂數分組, 必須先了解如何讀進 (with 與 open 及 read) 各班的學員檔案, 設法將各學員的學號轉進數列 (包含利用 splitlines() , 然後導入 random, 並且了解 random.shuffle() 的用法. \n 接著在編寫學員亂數分組程式時, 則可按照下列流程配置上述各程式元件: \n \n 讀進學員資料, 設法將各學員學號轉入數列 \n 利用亂數模組中的 shuffle 函式, 隨機弄亂學員學號數列 \n 利用重複迴圈, 從學員學號數列中一一取出, 準備進行分組 \n 在迴圈中利用整數相除後取得餘數的規律, 依照每組幾人的規劃進行分組 \n 在分組過程, 再設法利用數列的 append, 將各組學員學號納為分組數列 \n 最後將各組數列再放入選課班級數列中備用 \n \n 本學期各班配合協同執行課程實習任務, 進行學員亂數分組, 以下為參考程式: \n import random\nfilename = \'cdbw3_student_list.txt\'\n# 每組人數\nnum_in_one_group = 11\n# 組序由 1 開始\ngroup = 1\n# 各班分組後所得數列\nc2019 = []\nwith open(filename) as f:\n    # 讀進全部檔案, 轉進數列, 並同時將各行的 \\n 去除\n    read_data = f.read().splitlines() \nprint("共有 " + str(len(read_data)) + " 位學員")\n# 利用 shuffle 將數列隨機弄亂\nrandom.shuffle(read_data)\nfor i in range(len(read_data)):\n    # 利用整數相除的餘數進行分組\n    if i%num_in_one_group == 0:\n        # 列出分隔符號\n        print("-"*20)\n        print("group " + str(group) +":")\n        # 在分組區隔時重置各組學員數列\n        group_list = []\n        print()\n        # 同時列出與分隔標註對應 i 的數列內容\n        print(read_data[i])\n        group_list.append(read_data[i])\n        group = group + 1\n    else:\n        # 逐一列出同組的其他學員\n        print(read_data[i])\n        group_list.append(read_data[i])\n    if i%num_in_one_group == 0:\n        c2019.append(group_list)\n# c2019 為該班分組後所得分組數列\nprint(c2019) \n 註: 第一週 cda 學員資料:  cdaw1_student_list.txt , 其他相關資料在倉儲 data 目錄下. \n 另外, 本學期除學員自評外, 加入各組學員互評機制, 請各組實際根據課程評量表單取回之資料, 以程式進行處理, 並提出此一評量機制可能帶來的問題與因應方案. \n 已知問題 \n 利用 mde At nfu At edu At tw G suite 建立自評與互評表單, 目前無法讓 gm At nfu At edu At tw 的用戶登入填表, 第一種解決方法為, 設法配合課程, 在 gm At nfu At edu At tw 網域帳號中重新建立表格, 第二種解決方案則是, 為每一學員建立 mde At nfu At edu At tw 網域下的臨時課程帳號 (課程結束後刪除). \n', 'tags': '', 'url': '第一週分組程式.html'}, {'title': 'Git Book 摘要', 'text': 'https://git-scm.com/book/zh-tw/v2 \xa0 \n 開始 \n 使用 Git 的原因為: 希望利用分散式版次管理系統執行產品開發, 不重複存檔, 不讓各版次內容產生混淆, 且透過 Github, 可以多人協同, 並透過網際內容管理, 完整呈現開發歷程資料. \n 在 64 位元 Windows 10 環境中, 採用可攜版本, 無需安裝:\xa0 https://git-scm.com/download/win \xa0 \n Git 基本設定, 利用 \n git config --global user.name ""使用者" \n git config --global user.email "電子郵箱" \n git config --global http.proxy http://<username>:<password>@<proxy-server-url>:<port> \n 上述設定會儲存至可攜系統的 y:\\home\\.gitconfig 設定檔案中, 若在不同環境中有不同設定, 可以利用 start.bat 啟動系統時, 將 home 指定到所需的目錄中即可. \n Git 基礎 \n 取得 Git 倉儲的方法, 一方面在近端以 git init 建立新倉儲, 或從遠端 Git 伺服器, 以 git clone 取下某一倉儲檔案. \n 之後, 新增倉儲或 clone 之倉儲, 都可以利用 git add 對倉儲新增檔案內容, 或以編輯器修改既有的檔案. 倉儲內容改版後, 可以利用 git commit -m "提交說明" 在近端對倉儲提交, 聰遠端 clone 之倉儲, 可直接利用 git push 將倉儲改版內容推送到遠端. 而在近端新增之倉儲, 則必須先利用 git remote add 加入近端倉儲與特定遠端倉儲對應之設定後, 才能以 git push 將改版內容, 推送到遠端. \n 倘若在可攜系統中導入 ungit, 可以在近端利用圖形化介面, 檢視各倉儲的改版資料, 可以免除在近端使用 git status, git log, git checkout, git diff, git tag, git show 或 git reset 的指令. \n 使用 Git 分支 \n 參考:  簡述分支 \xa0 \n 使用分支的目的, 是希望從開發主線上分離開來, 然後在不影響主線的情況下繼續工作. 一旦在分支的改版內容獲得認可, 協同者便可利用 git merge, 將分支的版本納入開發主分支,\xa0 或者合併至其他分支中.', 'tags': '', 'url': 'Git Book 摘要.html'}, {'title': 'Github 自學', 'text': 'https://lab.github.com/ \xa0 \n Github 利用其 Issues 與 API 的程式編寫, 以網際自學架構讓使用者可以互動式流程, 學習與 Github 所提供功能有關的自學教材, 其中包括: \n Github 簡介:\xa0 https://lab.github.com/githubtraining/introduction-to-github \xa0 \n Html 簡介:\xa0 https://lab.github.com/githubtraining/introduction-to-html \xa0 \n 利用 Markdown 進行溝通:\xa0 https://lab.github.com/githubtraining/communicating-using-markdown \xa0 \n Github Pages:\xa0 https://lab.github.com/githubtraining/github-pages \xa0 \n 處理合併與衝突:\xa0 https://lab.github.com/githubtraining/managing-merge-conflicts \xa0 \n 審核拉回請求:\xa0 https://lab.github.com/githubtraining/reviewing-pull-requests \xa0 \n 利用 Travis CI 進行整合:\xa0 https://lab.github.com/githubtraining/continuous-integration-with-travis-ci \xa0', 'tags': '', 'url': 'Github 自學.html'}, {'title': 'w1取分項目', 'text': '本學期針對各實習任務, 加入取分項目, 各組可以將此項目分配給組員, 完成後可以在自評或互評中做為取分任務. \n W1 任務一項目一: 在利用亂數分組, 能否根據已經完成的主程式, 編寫一個網際程式或單機 PyQt5 程式, 讀進相關資料檔案後, 在瀏覽器或 PYQt5 程式中顯示出結果. \n W1 任務一項目二:\xa0 由於一開始亂數分組程式中的 bug, 導致 2a 在分組時, 只得到 分組結果 , 並無分組數列, 能否編寫一個程式讀進此一分組結果, 然後列出與  2b 分組結果數列 相同格式的資料. \n W1任務一項目三: 根據\xa0 https://2019wcm.blogspot.com/search/label/ungit \xa0為 ungit 寫一個使用手冊. \n', 'tags': '', 'url': 'w1取分項目.html'}, {'title': '實習任務二', 'text': '學習要點 \n 此任務將逐一導入\xa0 http://www.coppeliarobotics.com/helpFiles/en/tutorials.htm \xa0中的導引內容. \n 首先上場的是: \n http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm \xa0 \n 各學員執行任務 \n 各學員完成上述 Tutorial 後, 請將個人心得放入個人的課程網頁中. \n 分組專題 \n 請各組利用  OnShape  或其他 MCAD (Mechanical Computer Aided Design) 套件, 以協同模式建立手足球系統, 並將零組件輸入  V-rep , 以建立可以兩兩競賽用的動態系統. \n 技術需求: \n \n 建立系統所需的 3D 零組件 (利用  Onshape  或其他 MCAD 套件完成) \n 將零組件轉入  V-rep  (轉入後是否需要簡化,? 如何簡化? 如何設定模擬參數?) \n 分辨運動 ( Kinematics ) 模擬與動力 ( Dynamics ) 模擬的差異. \n 如何設定各操縱桿的平移軸 (Prismatic  Joint ) 運動? \n 如何設定各 操縱桿的旋轉軸 (Revolute  Joint ) 運動? \n 如何設定各人偶與足球之間的碰撞 動力 擊球模擬 ? \n 如何利用鍵盤中的字母鍵控制操縱桿的平移軸與旋轉軸 \n 如何利用程式 ( Lua  或  Python ) 控制 操縱桿的平移軸與旋轉軸 \n 如何 感測 足球通過球門? \n 如何利用  Qt 表單 紀錄雙方得分? \n 人偶擊球受力時的應用分析, 可採用  Range3  進行分析. \n \n \n \n 足球員尺寸: \n \n 參考:\xa0 https://www.thingiverse.com/thing:1090 \xa0 and\xa0 https://www.thingiverse.com/thing:2563055 \xa0 \n 足球尺寸: 36mm diameter; weighs 17 grams 材料: ABS Plastic \n 參考影片 \n \n \n \n \n \n \n \n The Design of a Semi-Automated Football Table.pdf \n Automated Football Table Thesis.pdf \n \n https://github.com/FoosAI/FoosAI \xa0 \n Design of a RoboCup Shooting Mechanism report.pdf \n Design of a Ball Handling Mechanism for RoboCup report.pdf \n 延伸專案 \n 在 Windows 10 環境中, 以  MSYS2  編譯 V-rep ( https://github.com/CoppeliaRobotics/v_rep ). \n V-rep 其他版次原始碼.7z  (1.8 GB)', 'tags': '', 'url': '實習任務二.html'}, {'title': 'V-rep Introduction', 'text': 'V-rep 檔案格式討論: \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=7&t=199 \xa0 \n 主要討論訴求與重點在於機電資整合產品設計, 若無法透過 分散式版次管理 釐清每一次協同人員改版的詳細歷程與內容, 將難以讓產品開發流程透明且易於維護 (持續改進). \n 作者的建議是: 儘量將設計內容以模組化 (models) 單元建構, 然後透過外部 lua 程式導入, 便可彌補目前無文字檔案 ttt 或 ttm 格式時, 無法透過分散式版次管理進行協同設計的遺憾. \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=7&t=2319 \xa0 \n 討論重點在於: 因為運動與動力模擬系統模型所需納入的資料眾多, 且必須考慮與舊版格式相容, 加上壓縮與內容查驗上的特殊設計要求, 希望利用文字檔案建立 ttt 或 ttm 有一定的難度 (或者礙於 商業考量 ), 目前只能透過既有的外部延伸程式架構進行處理. \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=7&t=7513 \n 討論重點仍以 分散式版次管理 上的需求為主,\xa0 \n Without version control is almost impossible to work on a V-REP project in a team and even working alone there are several problems like not knowing which are the difference between two version of the same model/scene \n 但是作者的答覆與五年前一模一樣, 希望具備版次管理的開發流程, 仍需搭配模組化 models\xa0 與 Lua 或 Python 程式進行, 之後則將透過\xa0 http://www.coppeliarobotics.com/helpFiles/en/blueZeroPlugin.htm \xa0介面 ( Bluezero 原始碼 ), 尋求更方便的整合. \n 目前的結論為: V-rep 所揭櫫的是一種開放式創新工作模式, 利用主軸技術 (Lua 搭配 C++) 作為核心, 其餘的 GUI 或整合各式動力分析、轉檔與模型搭建, 都納為延伸模組, 從開發者的角度, 利用 Lua 與 Python 原始碼可以操控任何以 C++ 編寫的核心功能, 因此協同分散式版次管理可以在 Programming 的層次運行. \n 但就使用 GUI 流程建模的一般用戶, 若無法充分掌握 V-rep 整體程式架構, 必須透過人工方式搭建各種分析功能, 目前只能以觀賞的角度來看 V-rep 所帶出的未來機器人整合開發趨勢. \n V-rep 主核心程式庫 \n https://github.com/CoppeliaRobotics/v_rep \xa0is the\xa0 V-rep core library:\xa0 \n v_rep.dll\xa0 \n libv_rep.dll.a \n 編譯上述程式庫所需設定檔案 ( 編譯參考 ): \n # location of boost headers:\n    BOOST_INCLUDEPATH = "y:/boost_1_66_0"    # (e.g. Windows)\n    #BOOST_INCLUDEPATH = "/usr/local/include"    # (e.g. MacOS)\n\n# location of lua headers:\n    LUA_INCLUDEPATH = "y:/lua-5.1.5/src"    # (e.g. Windows)\n    #LUA_INCLUDEPATH = "../../../../../mingw64/include/lua5.1"    # (e.g. Windows-MSYS2)\n    #LUA_INCLUDEPATH = "../../lua5_1_4_Linux26g4_64_lib/include"    # (e.g. Ubuntu)\n    #LUA_INCLUDEPATH = "/usr/local/include/lua5.1"    # (e.g. MacOS)\n\n# lua libraries to link:\n    LUA_LIBS = "y:/lua-5.1.5/src/liblua.a"    # (e.g. Windows)\n    #LUA_LIBS = -llua5.1    # (e.g. Windows-MSYS2)\n    #LUA_LIBS = -L"../../lua5_1_4_Linux26g4_64_lib/" -llua5.1    # (e.g. Ubuntu)\n    #LUA_LIBS = "/usr/local/lib/liblua5.1.dylib"    # (e.g. MacOS)\n\n# qscintilla location:\n    QSCINTILLA_DIR = "y:/QScintilla_gpl-2.10.2"    # (e.g. Windows)\n    #QSCINTILLA_DIR = "../../QScintilla-commercial-2.7.2"    # (e.g. Windows-MSYS2)\n    #QSCINTILLA_DIR = "../../QScintilla-commercial-2.7.2"    # (e.g. Ubuntu)\n    #QSCINTILLA_DIR = "../../QScintilla-commercial-2.7.2"    # (e.g. MacOS)\n\n# qscintilla headers:\n    QSCINTILLA_INCLUDEPATH = "$${QSCINTILLA_DIR}/include" "$${QSCINTILLA_DIR}/Qt4Qt5"\n\n# qscintilla libraries to link:\n    QSCINTILLA_LIBS = "$${QSCINTILLA_DIR}/libqscintilla2_qt5d.dll.a"    # (e.g. Windows)\n    #QSCINTILLA_LIBS = "$${QSCINTILLA_DIR}/release/release/libqscintilla2.dll.a"    # (e.g. Windows-MSYS2)    \n    #QSCINTILLA_LIBS = "$${QSCINTILLA_DIR}/release/libqscintilla2.so"    # (e.g. Ubuntu)\n    #QSCINTILLA_LIBS = "$${QSCINTILLA_DIR}/release/libqscintilla2.9.0.2.dylib"    # (e.g. MacOS)\n\n# Make sure if a config.pri is found one level above, that it will be used instead of this one:\n    exists(../config.pri) { include(../config.pri) }\n \n 可見  Boost C++\xa0程式庫 ,  Lua 原始碼 與  QScintilla 原始碼 在 V-rep 系統中扮演重要角色. \n V-rep 主執行程式 \n https://github.com/CoppeliaRobotics/v_repClientApplication \xa0is the\xa0 V-rep client application for core library: \n vrep.exe \n 允許有 Qt GUI 或無 GUI 的介面執行, 同時載入 v_rep.dll 以及\xa0 plugin 程式庫 \n https://github.com/CoppeliaRobotics/remoteApi \xa0則定義 remoteAPI 的連結. \n V-rep 原始碼使用授權 \n V-rep 的程式碼全部開源, 但\xa0 https://github.com/CoppeliaRobotics/dynamicsPlugin \xa0與\xa0 https://github.com/CoppeliaRobotics/meshCalculationPlugin \xa0採商用或免費教育授權, 其餘原始碼採 GPL 3 授權. (詳見: http://www.coppeliarobotics.com/helpFiles/en/licensing.htm \xa0) \n 內建模型與場景 \n Default Models: \n https://github.com/CoppeliaRobotics/models \xa0 \n Default Scenes: \n https://github.com/CoppeliaRobotics/scenes \xa0 \n Lua 應用程式碼 \n Lua for V-rep and Blue REALITY: \n https://github.com/CoppeliaRobotics/lua \xa0 \n 其他程式庫 \n VxMath.dll \n https://github.com/CoppeliaRobotics/v_repMath \xa0 \n remoteAPI: \n https://github.com/CoppeliaRobotics/remoteApi \xa0 \n remoteAPi for Lua: \n https://github.com/CoppeliaRobotics/v_repExtLuaRemoteApiClient \xa0 \n C++ plugin framework: \n https://github.com/CoppeliaRobotics/v_repPlusPlus \xa0 \n Plugin skeleton: \n https://github.com/CoppeliaRobotics/v_repExtPluginSkeleton \xa0 \n Common files for Plugin: \n https://github.com/CoppeliaRobotics/common \xa0 \n stub generator: \n https://github.com/CoppeliaRobotics/v_repStubsGen \xa0 ( Example ) \n CAD data Import/Export Plugin: \n https://github.com/CoppeliaRobotics/v_repExtAssimp \xa0 \n Qt Custom GUI interface Plugin: \n https://github.com/CoppeliaRobotics/v_repExtCustomUI \xa0 \n Lua parser Plugin: \n https://github.com/CoppeliaRobotics/v_repExtLuaParser \xa0 \n Video recorder library: \n https://github.com/CoppeliaRobotics/videoRecorder \xa0 \n use LuaJIT in stead of Lua library: \n https://github.com/CoppeliaRobotics/v_repLuaLibrary \xa0 \n Convex hull library: \n https://github.com/CoppeliaRobotics/v_repExtQhull \xa0 \n Image Plugin: \n https://github.com/CoppeliaRobotics/v_repExtImage \xa0 \n ROS interface Plugin: \n https://github.com/CoppeliaRobotics/v_repExtRosInterface \xa0 \n Surface reconstruction Plugin: \n https://github.com/CoppeliaRobotics/v_repExtSurfaceReconstruction \xa0 \n Cloud point matching plugin: \n https://github.com/CoppeliaRobotics/v_repExtICP \xa0', 'tags': '', 'url': 'V-rep Introduction.html'}, {'title': 'BubbleRob', 'text': 'V-rep user manual: \n http://www.coppeliarobotics.com/helpFiles/ \n BubbleRob Tutorial: \n http://www.coppeliarobotics.com/helpFiles/en/bubbleRobTutorial.htm \xa0 \n 操作步驟參考:\xa0 http://fid.cl/courses/ai-robotics/vrep-tut/tutorial_VREP_bob.pdf \xa0 ( tutorial_VREP_bob.pdf ) \n introduction_to_robotics_mechanics_planning_and_control.pdf \n modern_robotics.zip \n modern_robotics_lib.zip \xa0( https://github.com/NxRLab/ModernRobotics  ) \n Inverse Kinematics.pdf \n modern_robotics_exercise.pdf \n V-rep Introduction:\xa0 http://hades.mech.northwestern.edu/index.php/V-REP_Introduction \xa0 \n Get started with V-rep:\xa0 http://hades.mech.northwestern.edu/index.php/Getting_Started_with_the_V-REP_Simulator \xa0 \n 動態模擬考量 \n If we run the simulation again, we can notice that both objects do not interfere anymore. However, we notice that BubbleRob slightly moves, even with locked motor. \n We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. \n This has to do with the objects masses: Keep masses similar and not too light. When linking two shapes with a dynamically enabled joint or a dynamically enabled force sensor, make sure the two shape’s masses are not too different (m1 < 10 ∗ m2 and m2 < 10 ∗ m1), otherwise the joint or force sensor might be very soft and wobbly and present large positional/orientational errors (this effect can however also be used as a natural damping sometimes). \n Additionally, very low mass shapes should be avoided since they won’t be able to exert very large forces onto other shapes (even if propelled by high force actuators!). Lastly, the intertia has a role to play: Keep principal moments of inertia* relatively large. \n Try keeping the principal moments of inertia / mass (*refer to the shape dynamics properties dialog) relatively large, otherwise mechanical chains might be difficult to control and/or might behave in a strange way. \n Therefore, we need to multiply all involved object’s masses by 8 \n 建立 Model \n We now need to finish\xa0 BubbleRob \xa0 as a \xa0 model \xa0 definition. We select the model base (i.e. object \xa0 bubbleRob ) then check items \xa0 Object is model base \xa0 and \xa0 Object/model can transfer or accept DNA \xa0 in the \xa0 object common properties : there is now a stippled bounding box that encompasses all objects in the model hierarchy.  \n We select the two joints, the proximity sensor and the graph, then enable item \xa0 Ignored by model bounding box \xa0 and click \xa0 Apply to selection , in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable \xa0 camera visibility layer \xa0 2, and enable \xa0 camera visibility layer \xa0 10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default.  \n At any time we can \xa0 modify the visibility layers for the whole scene . To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item \xa0 Select base of model instead : if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. \n  Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. This is what we have: \n 新增 Vision Sensor \n Next we will add a vision sensor, at the same position and orientation as BubbleRob\'s proximity sensor. We open the model hierarchy again, then click [Menu bar --> Add --> Vision sensor --> Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0).  \n We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open its properties dialog. We set the Far clipping plane item to 1, and the Resolution x and Resolution y items to 256 and 256.  \n We then open the vision sensor filter dialog by clicking Show filter dialog. We select the filter component Edge detection on work image and click Add filter. We position the newly added filter in second position (one position up, using the up button). We double-click the newly added filter component and adjust its Threshold item to 0.2, then click OK. We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --> View --> Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process).  \n To be able to see the vision sensor\'s image, we start the simulation, then stop it again. The last thing that we need for our scene is a small child script that will control BubbleRob\'s behavior. We select bubbleRob and click [Menu bar --> Add --> Associated child script --> Non threaded]. This just added a non-threaded child script to the scene, and associated it with bubbleRob.  \n We can also add, remove or modify scripts via the script dialog which can be opened with [Menu bar --> Tools --> Scripts] or through the appropriate toolbar button: \n Lua 控制程式 \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n Building Clean Model \n http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm \xa0 \n Designing Dynamic Simulation \n http://www.coppeliarobotics.com/helpFiles/en/designingDynamicSimulations.htm#staticAndRespondable \xa0 \n ResizeableFloor \n 網際 Lua 程式執行環境:\xa0 http://mde.tw/vecp2018/lua/SchoolProject/ \xa0 \n function sysCall_init()\n    model=sim.getObjectAssociatedWithScript(sim.handle_self)\n    e1=sim.getObjectHandle(\'ResizableFloor_5_25_element\')\n    e2=sim.getObjectHandle(\'ResizableFloor_5_25_visibleElement\')\nend\n\nfunction sysCall_cleanup()\n    hideDlg()\nend\n\nfunction sysCall_nonSimulation()\n    local s=sim.getObjectSelection()\n    if s and #s>=1 and s[1]==model then\n        showDlg()\n    else\n        hideDlg()\n    end\nend\n\nfunction sysCall_beforeSimulation()\n    hideDlg()\nend\n\nfunction sysCall_beforeSimulation()\n    hideDlg()\nend\n\nfunction updateFloor()\n    local c=readInfo()\n    local sx=c[\'sizes\'][1]/5\n    local sy=c[\'sizes\'][2]/5\n    local sizeFact=sim.getObjectSizeFactor(model)\n    sim.setObjectParent(e1,-1,true)\n    local child=sim.getObjectChild(model,0)\n    while child~=-1 do\n        sim.removeObject(child)\n        child=sim.getObjectChild(model,0)\n    end\n    local xPosInit=(sx-1)*-2.5*sizeFact\n    local yPosInit=(sy-1)*-2.5*sizeFact\n    local f1,f2\n    for x=1,sx,1 do\n        for y=1,sy,1 do\n            if (x==1)and(y==1) then\n                sim.setObjectParent(e1,model,true)\n                f1=e1\n            else\n                f1=sim.copyPasteObjects({e1},0)[1]\n                f2=sim.copyPasteObjects({e2},0)[1]\n                sim.setObjectParent(f1,model,true)\n                sim.setObjectParent(f2,f1,true)\n            end\n            local p=sim.getObjectPosition(f1,sim.handle_parent)\n            p[1]=xPosInit+(x-1)*5*sizeFact\n            p[2]=yPosInit+(y-1)*5*sizeFact\n            sim.setObjectPosition(f1,sim.handle_parent,p)\n        end\n    end\nend\n\nfunction getDefaultInfoForNonExistingFields(info)\n    if not info[\'version\'] then\n        info[\'version\']=0\n    end\n    if not info[\'sizes\'] then\n        info[\'sizes\']={1,1}\n    end\nend\n\nfunction readInfo()\n    local data=sim.readCustomDataBlock(model,\'XYZ_FLOOR_INFO\')\n    if data then\n        data=sim.unpackTable(data)\n    else\n        data={}\n    end\n    getDefaultInfoForNonExistingFields(data)\n    return data\nend\n\nfunction writeInfo(data)\n    if data then\n        sim.writeCustomDataBlock(model,\'XYZ_FLOOR_INFO\',sim.packTable(data))\n    else\n        sim.writeCustomDataBlock(model,\'XYZ_FLOOR_INFO\',\'\')\n    end\nend\n\nfunction updateUi()\n    local c=readInfo()\n    local sizeFact=sim.getObjectSizeFactor(model)\n    simUI.setLabelText(ui,1,\'X-size (m): \'..string.format("%.2f",c[\'sizes\'][1]*sizeFact),true)\n    simUI.setSliderValue(ui,2,c[\'sizes\'][1]/5,true)\n    simUI.setLabelText(ui,3,\'Y-size (m): \'..string.format("%.2f",c[\'sizes\'][2]*sizeFact),true)\n    simUI.setSliderValue(ui,4,c[\'sizes\'][2]/5,true)\nend\n\nfunction sliderXChange(ui,id,newVal)\n    local c=readInfo()\n    c[\'sizes\'][1]=newVal*5\n    writeInfo(c)\n    updateUi()\n    updateFloor()\nend\n\nfunction sliderYChange(ui,id,newVal)\n    local c=readInfo()\n    c[\'sizes\'][2]=newVal*5\n    writeInfo(c)\n    updateUi()\n    updateFloor()\nend\n\nfunction closeEventHandler(h)\n    sim.removeScript(sim.handle_self)\nend\n\nfunction showDlg()\n    if not ui then\n    xml = [[\n<ui title="Floor Customizer" closeable="true" on-close="closeEventHandler" resizable="false" activate="false">\n    <group layout="form" flat="true">\n        <label text="X-size (m): 1" id="1"/>\n        <hslider tick-position="above" tick-interval="1" minimum="1" maximum="5" on-change="sliderXChange" id="2"/>\n        <label text="Y-size (m): 1" id="3"/>\n        <hslider tick-position="above" tick-interval="1" minimum="1" maximum="5" on-change="sliderYChange" id="4"/>\n    </group>\n    <label text="" style="* {margin-left: 400px;}"/>\n</ui>\n]]\n        ui=simUI.create(xml)\n        if 2==sim.getInt32Parameter(sim.intparam_platform) then\n            -- To fix a Qt bug on Linux\n            sim.auxFunc(\'activateMainWindow\')\n        end\n        updateUi()\n    end\nend\n\nfunction hideDlg()\n    if ui then\n        simUI.destroy(ui)\n        ui=nil\n    end\nend\n \n 左右輪分別建立 slider: \n function sysCall_init()\n         \n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n    xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n                <label text="left motor speed" wordwrap="false" />\n                <hslider minimum="0" maximum="100" on-change="left_speedChange_callback" id="1"/>\n                <label text="right motor speed" wordwrap="false" />\n                <hslider minimum="0" maximum="100" on-change="right_speedChange_callback" id="2"/>\n            <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    left_speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    right_speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(left_speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\n    simUI.setSliderValue(ui,2,100*(left_speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\n    \nend\nfunction right_speedChange_callback(ui,id,newVal)\n    right_speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction left_speedChange_callback(ui,id,newVal)\n    left_speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\n\nfunction sysCall_actuation() \n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,left_speed)\n        sim.setJointTargetVelocity(rightMotor,right_speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-left_speed/2)\n        sim.setJointTargetVelocity(rightMotor,-right_speed/8)\n    end\nend\n\nfunction sysCall_cleanup() \n    simUI.destroy(ui)\nend \n \n \n', 'tags': '', 'url': 'BubbleRob.html'}, {'title': 'BubbleRob1', 'text': 'This tutorial will try to introduce quite many V-REP functionalities while designing the simple mobile robot\xa0 BubbleRob . The V-REP scene file related to this tutorial is located in V-REP\'s installation folder\'s \xa0 tutorials/BubbleRob \xa0 folder. Following figure illustrates the simulation scene that we will design: \n \n Since this tutorial will fly over many different aspects, make sure to also have a look at the \xa0 other tutorials , mainly the \xa0 tutorial about building a simulation model . First of all, freshly start V-REP. The simulator displays a default \xa0 scene . We will start with the body of \xa0 BubbleRob . \n We add a primitive sphere of diameter 0.2 to the scene with [Menu bar --> Add --> Primitive shape --> Sphere]. We adjust the \xa0 X-size \xa0 item to 0.2, then click \xa0 OK . The created sphere will appear in the \xa0 visibility layer \xa0 1 by default, and be \xa0 dynamic and respondable \xa0 (since we kept the item \xa0 Create dynamic and respondable shape \xa0 enabled). This means that \xa0 BubbleRob\'s \xa0 body will be falling and able to react to collisions with other respondable shapes (i.e. simulated by the physics engine). We can see this is the \xa0 shape dynamics properties : items \xa0 Body is respondable \xa0 and \xa0 Body is dynamic \xa0 are enabled. We start the simulation (via the toolbar button, or by pressing <control-space> in the scene window), and copy-and-paste the created sphere (with [Menu bar --> Edit --> Copy selected objects] then [Menu bar --> Edit -> Paste buffer], or with <control-c> then <control-v>): the two spheres will react to collision and roll away. We stop the simulation: the duplicated sphere will automatically be removed. This default behaviour can be modified in the \xa0 simulation dialog . \n We also want the \xa0 BubbleRob\'s \xa0 body to by usable by the other calculation modules (e.g. the \xa0 minimum distance calculation module ). For that reason, we enable \xa0 Collidable , \xa0 Measurable , \xa0 Renderable \xa0 and \xa0 Detectable \xa0 in the \xa0 object common properties \xa0 for that shape, if not already enabled. If we wanted, we could now also change the visual appearance of our sphere in the \xa0 shape properties . \n Now we open the \xa0 position dialog \xa0 on the \xa0 translation \xa0 tab, select the sphere representing \xa0 BubbleRob\'s \xa0 body, and enter 0.02 for \xa0 Along Z . We make sure that the Relative to -item is set to \xa0 World . Then we click \xa0 Translate selection . This translates all selected objects by 2 cm along the absolute Z-axis, and effectively lifted our sphere a little bit. In the \xa0 scene hierarchy , we double-click the sphere\'s name, so that we can edit its name. We enter \xa0 bubbleRob \xa0 and press enter. \n Next we will add a \xa0 proximity sensor \xa0 so that \xa0 BubbleRob \xa0 knows when it is approaching obstacles: we select [Menu bar --> Add --> Proximity sensor --> Cone type]. In the \xa0 orientation dialog \xa0 on the \xa0 orientation \xa0 tab, we enter 90 for \xa0 Around Y \xa0 and for \xa0 Around Z , then click \xa0 Rotate selection . In the \xa0 position dialog , on the \xa0 position tab, we enter 0.1 for \xa0 X-coord. \xa0 and 0.12 for \xa0 Z-coord. \xa0 The proximity sensor is now correctly positioned relative to \xa0 BubbleRob\'s \xa0 body. We double-click the proximity sensor\'s icon in the \xa0 scene hierarchy \xa0 to open \xa0 its properties \xa0 dialog. We click \xa0 Show volume parameter \xa0 to open the \xa0 proximity sensor volume dialog . We adjust items \xa0 Offset \xa0 to 0.005, \xa0 Angle \xa0 to 30 and \xa0 Range \xa0 to 0.15. Then, in the \xa0 proximity sensor properties , we click \xa0 Show detection parameters . This opens the \xa0 proximity sensor detection parameter dialog . We uncheck item \xa0 Don\'t allow detections if distance smaller than \xa0 then close that dialog again. In the scene hierarchy, we double-click the proximity sensor\'s name, so that we can edit its name. We enter \xa0 bubbleRob_sensingNose \xa0 and press enter. \n \n We select \xa0 bubbleRob_sensingNose , then control-select \xa0 bubbleRob , then click [Menu bar --> Edit --> Make last selected object parent]. This attaches the sensor to the body of the robot. We could also have dragged \xa0 bubbleRob_sensingNose \xa0 onto \xa0 bubbleRob \xa0 in the scene hierarchy. This is what we now have: \n \n Next we will take care of \xa0 BubbleRob\'s \xa0 wheels. We create a new scene with [Menu bar --> File --> New scene]. It is often very convenient to work across several scenes, in order to visualize and work only on specific elements. We add a pure primitive cylinder with dimensions (0.08,0.08,0.02). As for the body of \xa0 BubbleRob , we enable \xa0 Collidable , \xa0 Measurable , \xa0 Renderable \xa0 and \xa0 Detectable \xa0 in the \xa0 object common properties \xa0 for that cylinder, if not already enabled. Then we set the cylinder\'s absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0). We change the name to \xa0 bubbleRob_leftWheel . We copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. We rename the copy to \xa0 bubbleRob_rightWheel . We select the two wheels, copy them, then switch back to scene 1, then paste the wheels. \n We now need to add \xa0 joints \xa0 (or motors) for the wheels. We click [Menu bar --> Add --> Joint --> Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. We Keep the joint selected, then control-select \xa0 bubbleRob_leftWheel . In the \xa0 position dialog , on the \xa0 position \xa0 tab, we click the \xa0 Apply to selection \xa0 button: this positioned the joint at the center of the left wheel. Then, in the \xa0 orientation dialog , on the \xa0 orientation \xa0 tab, we do the same: this oriented the joint in the same way as the left wheel. We rename the joint to \xa0 bubbleRob_leftMotor . We now double-click the joint\'s icon in the scene hierarchy to open the \xa0 joint properties \xa0 dialog. Then we click \xa0 Show dynamic parameters \xa0 to open the \xa0 joint dynamics properties dialog. We \xa0 enable the motor , and check item \xa0 Lock motor when target velocity is zero . We now repeat the same procedure for the right motor and rename it to \xa0 bubbleRob_rightMotor . Now we attach the left wheel to the left motor, the right wheel to the right motor, then attach the two motors to \xa0 bubbleRob . This is what we have: \n \n We run the simulation and notice that the robot is falling backwards. We are still missing a third contact point to the floor. We now add a small slider (or caster). In a new scene we and add a pure primitive sphere with diameter 0.05 and make the sphere\xa0 Collidable , \xa0 Measurable , \xa0 Renderable \xa0 and \xa0 Detectable \xa0 (if not already enabled), then rename it to \xa0 bubbleRob_slider . We set the \xa0 Material \xa0 to \xa0 noFrictionMaterial \xa0 in the \xa0 shape dynamics properties . To rigidly link the slider with the rest of the robot, we add a \xa0 force sensor object \xa0 with [Menu bar --> Add --> Force sensor]. We rename it to \xa0 bubbleRob_connection \xa0 and shift it up by 0.05. We attach the slider to the force sensor, then copy both objects, switch back to scene 1 and paste them. We then shift the force sensor by -0.07 along the absolute X-axis, then attach it to the robot body. If we run the simulation now, we can notice that the slider is slightly moving in relation to the robot body: this is because both objects (i.e. \xa0 bubbleRob_slider \xa0 and \xa0 bubbleRob ) are colliding with each other. To avoid strange effects during dynamics simulation, we have to inform V-REP that both objects do not mutually collide, and we do this in following way: in the \xa0 shape dynamics properties , for \xa0 bubbleRob_slider \xa0 we set the \xa0 local respondable mask \xa0 to 00001111, and for \xa0 bubbleRob , we set the \xa0 local respondable mask \xa0 to 11110000. If we run the simulation again, we can notice that both objects do not interfere anymore. This is what we now have: \n We run the simulation again and notice that \xa0 BubbleRob \xa0 slightly moves, even with locked motor. We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. For an explanation of this effect, make sure to carefully read \xa0 this \xa0 and \xa0 that \xa0 sections. We now try to correct for that undesired effect. We select the two wheels and the slider, and in the shape dynamics dialog we click three times \xa0 M=M*2 (for selection) . The effect is that all selected shapes will have their masses multiplied by 8. We do the same with the inertias of the 3 selected shapes, then run the simulation again: stability has improved. In the joint dynamics dialog, we set the \xa0 Target velocity \xa0 to 50 for both motors. We run the simulation: \xa0 BubbleRob \xa0 now moves forward and eventually falls off the floor. We reset the \xa0 Target velocity \xa0 item to zero for both motors. \n The object \xa0 bubbleRob \xa0 is at the base of all \xa0 objects \xa0 that will later form the \xa0 BubbleRob \xa0 model . We will define the model a little bit later. In the mean time, we want to define a collection of objects that represent \xa0 BubbleRob . For that we define a \xa0 collection object . We click [Menu bar --> Tools --> Collections] to open the \xa0 collection dialog . Alternatively we can also open the dialog by clicking the appropriate toolbar button: \n In the collection dialog, we click \xa0 Add new collection . A new collection object appears in the list just below. For now the newly added collection is still empty (not defined). While the new collection item is selected in the list, select \xa0 bubbleRob \xa0 in the scene hierarchy, and then click \xa0 Add \xa0 in the collection dialog. Our collection is now defined as containing all objects of the hierarchy tree starting at the \xa0 bubbleRob \xa0 object (the collection\'s composition is displayed in the \xa0 Composing elements and attributes \xa0 section). To edit the collection name, we double-click it, and rename it to \xa0 bubbleRob_collection . We close the collection dialog. \n At this stage we want to be able to track the minimum distance between BubbleRob and any other object. For that, we open the \xa0 distance dialog \xa0 with [Menu bar --> Tools --> Calculation module properties]. Alternatively we can also open the calculation module properties dialog with the appropriate toolbar button: \n In the distance dialog, we click \xa0 Add new distance object \xa0 and select a distance pair: \xa0 [collection] bubbleRob_collection - all other measurable objects in the scene . This just added a distance object that will measure the smallest distance between collection \xa0 bubbleRob_collection \xa0 (i.e. any \xa0 measurable object \xa0 in that collection) and any other measurable object in the scene. We rename the distance object to \xa0 bubbleRob_distance \xa0 with a double-click in its name. We close the distance dialog. When we now run the simulation, we won\'t see any difference, since the distance object will try to measure (and display) the smallest distance segment between \xa0 BubbleRob \xa0 and any other measurable object in the scene. The problem is that at this stage there is no other measurable object in the scene (the shape defining the floor has its measurable property turned off by default). At a later stage in this tutorial, we will add obstacles to our scene. \n Next we are going to add a \xa0 graph object \xa0 to \xa0 BubbleRob \xa0 in order to display above smallest distance, but also \xa0 BubbleRob\'s \xa0 trajectory over time. We click [Menu bar --> Add --> Graph] and rename it to \xa0 bubbleRob_graph . We attach the graph to \xa0 bubbleRob , and set the graph\'s absolute coordinates to (0,0,0.005). Now we open the \xa0 graph properties \xa0 dialog by double-clicking its icon in the scene hierarchy. We uncheck \xa0 Display XYZ-planes , then click \xa0 Add new data stream to record \xa0 and select \xa0 Object: absolute x-position \xa0 for the \xa0 Data stream type , and \xa0 bubbleRob_graph \xa0 for the \xa0 Object / item to record . An item has appeared in the \xa0 Data stream recording list . That item is a data stream of \xa0 bubbleRob_graph\'s \xa0 absolute x-coordinate (i.e. the \xa0 bubbleRobGraph\'s \xa0 object absolute x position will be recorded). Now we also want to record the y and z positions: we add those data streams in a similar way as above. We now have 3 data streams that represent BubbleRob\'s x-, y- and z-trajectories. We are going to add one more data stream so that we are able to track the minimum distance between our robot and its environment: we click \xa0 Add new data stream to record \xa0 and select \xa0 Distance: segment length \xa0 for the \xa0 Data stream type , and \xa0 bubbleRob_distance \xa0 for the \xa0 Object / item to record . In the \xa0 Data stream recording list , we now rename Data to bubbleRob_x_pos, Data0 to bubbleRob_y_pos, Data1 to bubbleRob_z_pos, and Data2 to bubbleRob_obstacle_dist. \n We select \xa0 bubbleRob_x_pos \xa0 in the \xa0 Data Stream recording list \xa0 and in the \xa0 Time graph properties \xa0 section, uncheck \xa0 Visible . We do the same for \xa0 bubbleRob_y_pos \xa0 and \xa0 bubbleRob_z_pos . By doing so, only the \xa0 bubbleRob_obstacle_dist \xa0 data stream will be visible in a time graph. Following is what we should have: \n Next we will set-up a 3D curve that displays \xa0 BubbleRob\'s \xa0 trajectory: we click \xa0 Edit 3D curves \xa0 to open the \xa0 XY graph and 3D curve dialog , then click \xa0 Add new curve . In the dialog that pops open, we select \xa0 bubbleRob_x_pos \xa0 for the \xa0 X-value \xa0 item, \xa0 bubbleRob_y_pos \xa0 for the \xa0 Y-value \xa0 item and \xa0 bubbleRob_z_pos \xa0 for the \xa0 Z-value \xa0 item. We rename the newly added curve from \xa0 Curve \xa0 to bubbleRob_path. Finally, we check the \xa0 Relative to world \xa0 item and set \xa0 Curve width \xa0 to 4: \n We close all dialogs related to graphs. Now we set one motor \xa0 target velocity \xa0 to 50, run the simulation, and will see \xa0 BubbleRob\'s \xa0 trajectory displayed in the scene. We then stop the simulation and reset the motor target velocity to zero. \n We add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, we disable \xa0 Body is dynamic \xa0 in the \xa0 shape dynamics properties . We also want our cylinder to be \xa0 Collidable , \xa0 Measurable , \xa0 Renderable \xa0 and \xa0 Detectable . We do this in the \xa0 object common properties . Now, while the cylinder is still selected, we click the object translation toolbar button: \n Now we can drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. We copy and paste the cylinder a few times, and move them to positions around \xa0 BubbleRob \xa0 (it is most convenient to perform that while looking at the scene from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the \xa0 regular direction(s). When done, select the camera pan toolbar button again: \n We set a \xa0 target velocity \xa0 of 50 for the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. We stop the simulation and reset the target velocity to zero. \n We now need to finish \xa0 BubbleRob \xa0 as a \xa0 model \xa0 definition. We select the model base (i.e. object \xa0 bubbleRob ) then check items \xa0 Object is model base \xa0 and \xa0 Object/model can transfer or accept DNA \xa0 in the \xa0 object common properties : there is now a stippled bounding box that encompasses all objects in the model hierarchy. We select the two joints, the proximity sensor and the graph, then enable item \xa0 Don\'t show as inside model selection \xa0 and click \xa0 Apply to selection , in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable \xa0 camera visibility layer \xa0 2, and enable \xa0 camera visibility layer \xa0 10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default. At any time we can \xa0 modify the visibility layers for the whole scene . To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item \xa0 Select base of model instead : if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. This is what we have: \n Next we will add a \xa0 vision sensor , at the same position and orientation as \xa0 BubbleRob\'s \xa0 proximity sensor. We open the model hierarchy again, then click [Menu bar --> Add --> Vision sensor --> Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0). We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open \xa0 its properties \xa0 dialog. We set the \xa0 Far clipping plane \xa0 item to 1, and the \xa0 Resolution x \xa0 and \xa0 Resolution y \xa0 items to 256 and 256. We then open the \xa0 vision sensor filter dialog \xa0 by clicking \xa0 Show filter dialog . We select the filter component \xa0 Edge detection on work image \xa0 and click \xa0 Add filter . We position the newly added filter in second position (one position up, using the \xa0 up \xa0 button). We double-click the newly added filter component and adjust its \xa0 Threshold \xa0 item to 0.2, then click \xa0 OK . We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --> View --> Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process). To be able to see the vision sensor\'s image, we start the simulation, then stop it again. \n The last thing that we need for our scene is a small \xa0 child script \xa0 that will control \xa0 BubbleRob\'s \xa0 behavior. We select \xa0 bubbleRob \xa0 and click [Menu bar --> Add --> Associated child script --> Non threaded]. This just added a \xa0 non-threaded child script \xa0 to the scene, and associated it with \xa0 bubbleRob . We can also add, remove or modify scripts via the \xa0 script dialog \xa0 which can be opened with [Menu bar --> Tools --> Scripts] or through the appropriate toolbar button: \n We double-click the little script icon that appeared next to\xa0 bubbleRob\'s \xa0 name in the scene hierarchy: this opens the child script that we just added. We copy and paste following code into the \xa0 script editor , then close it: \n function speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob\'s handle\n    leftMotor=sim.getObjectHandle("bubbleRob_leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObjectHandle("bubbleRob_rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObjectHandle("bubbleRob_sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectName(bubbleRobBase)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n\tsimUI.destroy(ui)\nend \n \n We run the simulation. \xa0 BubbleRob \xa0 now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change \xa0 BubbleRob\'s \xa0 velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation, depending on the environment. You can turn that functionality on and off in the \xa0 distance dialog , by checking / unchecking the \xa0 Enable all distance calculations \xa0 item. \n Using a script to control a robot or model is only one way of doing. V-REP offers many different ways (also combined), have a look at the \xa0 external controller tutorial . \n \n', 'tags': '', 'url': 'BubbleRob1.html'}, {'title': '實習任務三', 'text': 'http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm \xa0 \n 機械設計中的 Kinematic and Dynamic Modeling 中有許多建立模型的技巧, 在運用  V-rep  進行運動與動態模擬的過程中, 除了利用  Solvespace  或  OnShape  繪製系統所牽涉的零組件外, 還必須考慮模擬過程的實用性, 意即在機械系統概念設計初步階段, 必須要先掌握各零組件基本的運動與動態特性, 不必將零組件仍無法明確設計的特徵尺寸置入. \n 在這個實習任務中, 可以學習如何建立適用於  V-rep  的零件模型. \n 延伸任務 \n https://www.freecadweb.org/ \xa0目前已經能夠支援利用 Python3 程式建立模型 ( 註 1 ,  2 ,  3 ), 當建立與機械設計運動及動態模擬過程中, 最佳的零組件提供方案, 是透過各商用 MCAD 套件的 API 環境, 以電腦程式建構零組件, 因為此舉可以將更多與機械設計流程考量的約束條件置入, 以整合性更高的方式進行機械設計. \n 不過目前各商用 MCAD 套件的網際 API 程式環境較高, 此處希望以  Solvespace  中的 Solver ( https://github.com/KmolYuan/python-solvespace ), 或  FreeCAD  作為範例, 嘗試以可攜程式方法結合  V-rep , 自行建立所需的網際協同機械設計環境. \n 其他有關 Onshape 的 API 參考: \n https://forum.onshape.com/discussion/4030/where-can-i-find-the-apis-and-api-documentation-for-onshape-how-much-functionality-the-apis-cover \xa0 \n https://github.com/onshape-public/apikey \xa0 \n https://github.com/onshape-public/app-windows-sample \xa0 \n', 'tags': '', 'url': '實習任務三.html'}, {'title': '實習任務四', 'text': 'http://www.coppeliarobotics.com/helpFiles/en/lineFollowingBubbleRobTutorial.htm \xa0 \n 延伸應用 \n 以 Python 控制 V-rep 模型:\xa0 http://fid.cl/courses/ai-robotics/vrep-tut/pythonBubbleRob.pdf \xa0( pythonBubbleRob.pdf ) \n e-puck 控制範例: data/v-rep/e-puck_control_ex/', 'tags': '', 'url': '實習任務四.html'}, {'title': '實習任務五', 'text': 'http://www.coppeliarobotics.com/helpFiles/en/inverseKinematicsTutorial.htm \xa0 \n', 'tags': '', 'url': '實習任務五.html'}, {'title': '實習任務六', 'text': 'http://www.coppeliarobotics.com/helpFiles/en/externalControllerTutorial.htm \xa0 \n https://github.com/kmolab/pymcadp/tree/gh-pages/data/v-rep/vrep-api-python-demo \xa0 \n', 'tags': '', 'url': '實習任務六.html'}, {'title': '協同設計', 'text': '協同產品設計實習的三項內容管理系統 (Content Management Systems) 包含 \n CMSimfly  (循序頁面電子書) - 各組網際協同產品設計規劃與使用說明電子書 \n Reveal  (網際簡報系統) - 每一協同設計階段完成的簡要報告 \n Pelican Blog  (靜態網誌) - 依照日期紀錄各協同階段工作內容與結論 \n 下載可攜程式環境:  kmol_2019.7z \xa0(380MB, 解開約 1.5 GB) \n 開發要點 \n \n 多人協同編輯的 CMSimfly \n 近端網際 Reveal 編輯環境 \n 更容易使用的 Pelican 靜態網誌轉換系統 \n \n 機械設計內容表達 \n 利用  CMSimfly  進行口語、文字、2D 靜態檔案、3D 與動態影音、數學與實體表達. \n 口語表達 - 透過 Reveal.js 簡報協助隨時進行機械設計內容介紹與解說. \n 文字表達 - 編寫在內容管理系統中的中英文資料. \n 2D 靜態檔案 - images 與 pdf\xa0 等靜態檔案. \n 3D 與動態影音 - X3D, three.js 或 mp4 等動態資料. \n 數學表達 - 在內容管理系統中提供與機械設計相關的數學表示式及數學模型. \n 實體表達 - 將上述各階段所說明的機械設計系統零組件檔案, 經由實際加工製作成實體, 後以其他表達方式進行說明與介紹. \n', 'tags': '', 'url': '協同設計.html'}, {'title': 'Onshape', 'text': '特性 \n 現有免費的整合 CAX 系統, 應力分析, render, CAM? \n Featurescript 在協同產品開發流程中的角色 \n https://github.com/onshape \xa0 \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'BOMs', 'text': 'https://www.engineering.com/DesignSoftware/DesignSoftwareArticles/ArticleID/16985/First-Look-Onshape-Enterprise.aspx \xa0 ( pdf ) \n 發布管理 \n https://en.wikipedia.org/wiki/Release_management \xa0 \n https://www.engineering.com/DesignSoftware/DesignSoftwareArticles/ArticleID/16672/Onshape-Adds-Release-Management-Revamps-BOMs.aspx \xa0 ( pdf ) \n 參數建模與直接建模 \n https://www.engineering.com/DesignSoftware/DesignSoftwareArticles/ArticleID/16587/Whats-the-Difference-Between-Parametric-and-Direct-Modeling.aspx \xa0 ( pdf ) \n https://www.engineering.com/DesignSoftware/DesignSoftwareArticles/ArticleID/16304/We-Just-Remade-Parametric-Modeling-Says-Onshape.aspx \xa0 ( pdf ) \n 現代CAD機器設計.pdf \n 精通3D模擬.pdf \n 2018CAD技術趨勢.pdf \n 開解設計僵局.pdf \n 技術提示1.pdf \n 敏捷產品設計簡介.pdf \n NI_Mechatronics_Machine_Design_Guide.pdf \n c-k theory:\xa0 https://mde1a1.kmol.info/2017fall/wiki?name=c-k+design+theory \xa0 \n', 'tags': '', 'url': 'BOMs.html'}, {'title': 'V-rep', 'text': 'source:\xa0 http://hades.mech.northwestern.edu/index.php/Getting_Started_with_the_V-REP_Simulator \xa0 \n Now that you have the \xa0 MR code library , you need the cross-platform V-REP robot simulator to allow you to visualize the motions of robots. \xa0 You should complete the items on this page before moving on with the rest of the course! \xa0 Click on any of the images to make them larger. \n V-REP is computationally intensive. To minimize power usage, make sure to "pause" or "stop" a simulation when you are not using it. \n 1. \xa0 Go to \xa0 http://www.coppeliarobotics.com/ \xa0 and download and install the free V-REP PRO EDU software for your operating system. \n 2. \xa0 Launch V-REP and experiment with it. I suggest you choose File > Open scene... and open one of the example "scenes" that comes with V-REP. V-REP "scenes" are specifications of environments, robots, and their actions, and when you press the "play" button the simulation begins. Experimenting with these scenes will show you some of the capabilities of V-REP. For example, you could choose the "motionPlanningAndGrasping.ttt" scene, as shown in the image below. (All scene files end in .ttt.) \n \n v-rep_remoteapi_ex.7z', 'tags': '', 'url': 'V-rep.html'}, {'title': 'V-rep Tutorial', 'text': "http://www.coppeliarobotics.com/helpFiles/en/tutorials.htm \xa0 \n V-rep Tutorial: \n \n Line Following Robot: \n \n V-rep Scripts Writing: \n \n Python Robot Simulation: \n \n Path Planning: \n \n Dynamic Module: \n \n V-rep Introduction and Bump Sensors: \n \n Inverse Kinematics: \n \n scene 模擬場景 - 包含環境與各種物件 \n scene object 場景中的物件 [http://www.coppeliarobotics.com/helpFiles/en/objects.htm] 包含 \n shape 零組件形體 \n camera 攝影機 \n light 光源 \n dummy 虛體 - 由一個有方位的點表示,沒有形體內容但具有形體性質的特殊物件 \n graph 圖形 \n path 路徑 \n mirror 鏡 \n point cloud 點雲 \n joint 軸 \n proximity sensor 近接感測器 \n vision sensor 視覺感測器 \n force/torque sensor 力/矩感測器 \n mill 銑 \n octree 八叉樹狀結構 \n model 場景中的模型 \n page 頁 - 每一個場景至多內置 8 個頁面, 每一個頁面則可以內置不限數量的視圖 (views), 頁面可視為視圖的容器. \n view 視圖 - 透過攝影機、圖型或視覺感測器取的資料, 用於顯示場景內容. \n Main Script \n A main script is a simulation script. By default, each scene in V-REP will have one main script. It contains the basic code that allows a simulation to run. Without main script, a running simulation won't do anything. \n The main script is called at each simulation step exactly one time. In addition to that, it is called once during initialization (at the start of a simulation), and once during restoration (at the end of a simulation). Thus, the default main script is segmented in 3 parts: \n the initialization part \n : this part will be executed one time just at the beginning of a simulation. The code is in charge of preparing a simulation, etc. \n the regular part \n : this part will be executed at each simulation pass. The code is in charge of handling all the functionality of the simulator (inverse kinematics, proximity sensors, collision detection, dynamics, etc.) in a generic way. Two commands are of particular interest: simLaunchThreadedChildScripts and simHandleChildScripts. simLaunchThreadedChildScripts launches threaded child scripts, while simHandleChildScripts runs non-threaded child scripts. Without those commands, child scripts won't be executed, and specific model functionality or behavior won't operate. The regular part is divided into an actuation (or action/reaction) section and a sensing (or probing) section. \n the restoration part \n : this part will be executed one time just before a simulation ends. The code is in charge of restoring object's initial configuration, clearing sensor stat \n", 'tags': '', 'url': 'V-rep Tutorial.html'}, {'title': 'v-rep ref', 'text': 'http://mde.tw/2017springcd/blog/vrep-planar-mechanism-simulation.html \xa0 \n http://mde.tw/2017springcd/blog/vrep-introduction.html \xa0 \n http://mde.tw/cadp2018/content/V-rep.html \xa0', 'tags': '', 'url': 'v-rep ref.html'}]};